reproject
=========

.. py:module:: reproject


Attributes
----------

.. autoapisummary::

   reproject.EPSILON


Classes
-------

.. autoapisummary::

   reproject.Reproject


Functions
---------

.. autoapisummary::

   reproject.interpolate_image
   reproject.get_sip_coeffs
   reproject.apply_sip_distortion
   reproject.apply_inverse_sip_distortion
   reproject.iterative_inverse_sip
   reproject.calculate_reprojection


Module Contents
---------------

.. py:data:: EPSILON
   :value: 1e-10


.. py:function:: interpolate_image(source_image: torch.Tensor, grid: torch.Tensor, interpolation_mode: str) -> torch.Tensor

   JIT-compiled image interpolation using grid_sample


.. py:function:: get_sip_coeffs(wcs: astropy.wcs.WCS) -> Tuple[torch.Tensor, torch.Tensor, torch.Tensor, torch.Tensor]

   Extract SIP polynomial coefficients from a WCS object.

   Parameters:
   -----------
   wcs : astropy.wcs.WCS
       WCS object potentially containing SIP distortion

   Returns:
   --------
   dict:
       Dictionary containing SIP coefficient matrices A, B, AP, BP and orders


.. py:function:: apply_sip_distortion(u: torch.Tensor, v: torch.Tensor, sip_coeffs: Tuple, device: str = 'cpu')

   Apply SIP distortion to intermediate pixel coordinates.

   Parameters:
   -----------
   u, v : torch.Tensor
       Intermediate pixel coordinates (before distortion)
   sip_coeffs : Tuple[torch.Tensor, torch.Tensor, torch.Tensor, torch.Tensor]
       SIP coefficient matrices
   device : torch.device, optional
       Device to place tensors on

   Returns:
   --------
   tuple:
       (u', v') distorted coordinates


.. py:function:: apply_inverse_sip_distortion(u: torch.Tensor, v: torch.Tensor, sip_coeffs: Tuple, device: str = 'cpu')

   Apply inverse SIP distortion to go from distorted to intermediate coordinates.

   Parameters:
   -----------
   u, v : torch.Tensor
       Distorted coordinates
   sip_coeffs : Tuple
       SIP coefficient matrices
   device : torch.device, optional
       Device to place tensors on

   Returns:
   --------
   tuple:
       (u', v') undistorted coordinates


.. py:function:: iterative_inverse_sip(u: torch.Tensor, v: torch.Tensor, sip_coeffs: Tuple, device: str = 'cpu', max_iter: int = 20, tol: float = 1e-08)

   Iteratively solve for undistorted coordinates when inverse SIP coefficients
   are not available.

   Parameters:
   -----------
   u, v : torch.Tensor
       Distorted coordinates
   sip_coeffs : Tuple
       SIP coefficient matrices
   device : torch.device, optional
       Device to place tensors on
   max_iter : int, optional
       Maximum number of iterations
   tol : float, optional
       Convergence tolerance

   Returns:
   --------
   tuple:
       (u', v') undistorted coordinates


.. py:class:: Reproject(source_hdu: astropy.io.fits.PrimaryHDU, target_hdu: astropy.io.fits.PrimaryHDU)

   .. py:attribute:: device


   .. py:attribute:: target_image


   .. py:attribute:: source_image


   .. py:attribute:: target_wcs_astropy


   .. py:attribute:: source_wcs_astropy


   .. py:attribute:: target_grid


   .. py:method:: calculate_skyCoords(x=None, y=None)

      Calculate sky coordinates using Astropy WCS implementation.



   .. py:method:: calculate_sourceCoords()

      Calculate source image pixel coordinates corresponding to each target image pixel.



   .. py:method:: interpolate_source_image(interpolation_mode='bilinear')

      Interpolate the source image at the calculated source coordinates with flux conservation.

      This method performs the actual pixel resampling needed for reprojection
      while preserving the total flux (photometric accuracy). It implements a
      footprint-based approach similar to that used in reproject_interp from the
      Astropy package.

      The method uses a combined tensor approach for computational efficiency,
      performing both image resampling and footprint tracking in a single operation.
      Total flux is conserved both locally (via footprint correction) and globally
      (via final normalization).

      :param interpolation_mode: The interpolation mode to use when sampling the source image.
                                 Options include:
                                 - 'nearest' : Nearest neighbor interpolation (no interpolation)
                                 - 'bilinear' : Bilinear interpolation (default)
                                 - 'bicubic' : Bicubic interpolation

                                 These correspond to the modes available in torch.nn.functional.grid_sample.
      :type interpolation_mode: str, default 'bilinear'

      :returns: The reprojected image with the same shape as the target image.
                Pixel values are interpolated from the source image according to
                the WCS transformation with flux conservation preserved.
      :rtype: torch.Tensor

      .. rubric:: Notes

      This implementation uses a two-step flux conservation approach:

      1. Local flux conservation: The image and a "ones" tensor are interpolated
         together, and the interpolated image is divided by the interpolated ones
         tensor (footprint) to correct for any flux spreading during interpolation.

      2. Global flux conservation: The total flux of the output image is normalized
         to match the total flux of the input image.

      Areas in the target image that map outside the source image boundaries
      will be filled with zeros (using 'zeros' padding_mode).

      This method is particularly suitable for high-precision photometry with
      extended sources, as it properly preserves both the background noise
      characteristics and the flux distribution of sources.



.. py:function:: calculate_reprojection(source_hdu: astropy.io.fits.PrimaryHDU, target_hdu: astropy.io.fits.PrimaryHDU, interpolation_mode='nearest')

   Reproject an astronomical image from a source WCS to a target WCS.

   This high-level function provides a convenient interface for image reprojection,
   handling all the necessary steps: WCS extraction, tensor creation, and interpolation.
   It converts FITS HDU objects to the internal representation, performs the reprojection,
   and returns the resulting image as a PyTorch tensor.

   :param source_hdu: The source image HDU containing the image data to be reprojected and
                      its associated WCS information in the header.
   :type source_hdu: fits.PrimaryHDU
   :param target_hdu: The target image HDU providing the output grid and WCS information. The
                      shape of target_hdu.data defines the dimensions of the output image.
   :type target_hdu: fits.PrimaryHDU
   :param interpolation_mode: The interpolation method to use when resampling the source image.
                              Options:
                              - 'nearest' : Nearest neighbor interpolation (fastest, default)
                              - 'bilinear' : Bilinear interpolation (good balance of speed/quality)
                              - 'bicubic' : Bicubic interpolation (highest quality, slowest)
   :type interpolation_mode: str, default 'nearest'

   :returns: The reprojected image as a PyTorch tensor with the same shape as
             target_hdu.data. The tensor is on the same device as the computation
             (GPU if available, otherwise CPU).
   :rtype: torch.Tensor

   .. rubric:: Notes

   This function automatically:
   - Detects and uses GPU acceleration if available
   - Handles byte order conversion for tensor creation
   - Converts data to float32 for processing
   - Creates WCSHeader objects from FITS headers

   To save the result as a FITS file, you will need to convert the tensor
   back to a NumPy array and create a new FITS HDU with the target WCS header.

   .. rubric:: Examples

   >>> from astropy.io import fits
   >>> import torch
   >>> from reprojection.reproject import calculate_reprojection
   >>>
   >>> # Open source and target images
   >>> source_hdu = fits.open('source_image.fits')[0]
   >>> target_hdu = fits.open('target_grid.fits')[0]
   >>>
   >>> # Perform reprojection with bilinear interpolation
   >>> reprojected = calculate_reprojection(
   ...     target_hdu=target_hdu,
   ...     source_hdu=source_hdu,
   ...     interpolation_mode='bilinear'
   ... )
   >>>
   >>> # Convert back to NumPy and save as FITS
   >>> reprojected_np = reprojected.cpu().numpy()
   >>> output_hdu = fits.PrimaryHDU(data=reprojected_np, header=target_hdu.header)
   >>> output_hdu.writeto('reprojected_image.fits', overwrite=True)


